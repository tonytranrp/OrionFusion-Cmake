
class Tessellator { /* Size=0x230 */
  /* 0x0000 */ bool mIsFormatFixed;
  /* 0x0008 */ mce::MeshData mMeshData;
  /* 0x00f8 */ std::optional<glm::tvec4<float,0> > mNextNormal;
  /* 0x010c */ std::optional<glm::tvec2<float,0> > mNextUV[3];
  /* 0x0130 */ std::optional<unsigned int> mNextColor;
  /* 0x0138 */ std::optional<unsigned short> mNextBoneId;
  /* 0x013c */ std::optional<unsigned short> mNextPBRTextureIdx;
  /* 0x0140 */ bool mIndexPhase;
  /* 0x0144 */ Vec3 mPostTransformOffset;
  /* 0x0150 */ Vec3 mPostTransformScale;
  /* 0x015c */ unsigned char mQuadFacing;
  /* 0x015d */ bool mQuadTwoSided;
  /* 0x0160 */ std::vector<TessellatorQuadInfo,std::allocator<TessellatorQuadInfo> > mQuadInfoList;
  /* 0x0178 */ Vec3 mFaceCenterAccumulator;
  /* 0x0184 */ int32_t mCurQuadVertex;
  /* 0x0188 */ bool mApplyTransform;
  /* 0x018c */ glm::tmat4x4<float,0> mTransformMatrix;
  /* 0x01cc */ bool mNoColor;
  /* 0x01cd */ bool mVoidBeginEnd;
  /* 0x01ce */ bool mForceTessellateIntercept;
  /* 0x01d0 */ std::function<void __cdecl(Tessellator const &,mce::MaterialPtr const &,mce::TexturePtr const &)> mInterceptTessellator;
  /* 0x0210 */ uint32_t mCount;
  /* 0x0214 */ bool mTessellating;
  /* 0x0215 */ bool mBuildFaceData;
  /* 0x0218 */ std::unique_ptr<mce::Mesh,std::default_delete<mce::Mesh> > mPreGeneratedMesh;
  /* 0x0220 */ std::weak_ptr<mce::BufferResourceService> mBufferResourceService;
  static const int32_t MAX_MEMORY_USE;
  static const int32_t MAX_FLOATS;
  
  Tessellator(const Tessellator&);
  Tessellator(std::weak_ptr<mce::BufferResourceService>);
  ~Tessellator();
  void clear();
  void begin(const mce::PrimitiveMode, const int32_t, const bool);
  void begin(const int32_t, const bool);
  void beginWithMeshData(const mce::PrimitiveMode, const int32_t, mce::MeshData&, const bool);
  void setRecursive(mce::Color, std::vector<Vec3,std::allocator<Vec3> >, std::vector<Vec2,std::allocator<Vec2> >, std::vector<Vec2,std::allocator<Vec2> >, unsigned char, bool, int32_t);
  void cancel();
  mce::Mesh end(const gsl::basic_string_span<char const ,-1>);
  mce::Mesh end(const Tessellator::UploadMode, const gsl::basic_string_span<char const ,-1>);
  void triggerIntercept(const mce::MaterialPtr&, const mce::TexturePtr&);
  void beginIndices(uint64_t);
  void color(const mce::Color&);
  void color(unsigned char, unsigned char, unsigned char, unsigned char);
  void color(int32_t, int32_t, int32_t, int32_t);
  void color(float, float, float, float);
  void color(int32_t, int32_t);
  void color(int32_t);
  void colorABGR(int32_t);
  void pbrTextureIdx(const uint16_t&);
  void normal(const Vec3&, const float);
  void normal(float, float, float, float);
  void tex(const Vec2&);
  void tex(float, float);
  void tex1(const Vec2&);
  void tex1(float, float);
  void tex2(const Vec2&);
  void tex2(float, float);
  void bone0(const uint16_t);
  void vertex(const Vec3&);
  void vertex(float, float, float);
  void vertexUV(const Vec3&, const Vec2&);
  void vertexUV(const Vec3&, float, float);
  void vertexUV(float, float, float, float, float);
  void quadFacing(unsigned char);
  void quadTwoSided(bool);
  void quad(bool);
  void quad(uint32_t, bool);
  void quad(uint32_t, uint32_t, uint32_t, uint32_t);
  void triangle(uint32_t, uint32_t, uint32_t);
  void noColor();
  void enableColor();
  bool forceTessellateIntercept() const;
  void setTessellateIntercept(std::function<void __cdecl(Tessellator const &,mce::MaterialPtr const &,mce::TexturePtr const &)>);
  void overrideTessellateIntercept(std::function<void __cdecl(Tessellator const &,mce::MaterialPtr const &,mce::TexturePtr const &)>);
  void resetTessellateIntercept();
  void enableField(const mce::VertexField);
  bool hasField(const mce::VertexField) const;
  void trim();
  int32_t getByteSize() const;
  void applyDefaultTransform();
  void rotateAroundPivot(const Vec3&, const float, const Vec3&, bool);
  void resetTransform(bool);
  bool shouldApplyTransform() const;
  void setScaleTransform(const Vec3&);
  void setScaleTransform(float, float, float);
  void setRotation(float, const Vec3&);
  void addRotation(mce::Radian, const Vec3&);
  void addRotation(float, const Vec3&);
  void addTranslation(const Vec3&);
  void resetPostTransformScale();
  void postTransformScale(float, float, float);
  void setPostTransformOffset(const Vec3&);
  void setPostTransformOffset(float, float, float);
  void addPostTransformOffset(const Vec3&);
  void addPostTransformOffset(float, float, float);
  const Vec3& getPostTransformOffset() const;
  const glm::tmat4x4<float,0>& getTransformMatrix() const;
  uint32_t getVertexCount() const;
  int32_t getPolygonCount() const;
  bool isTessellating() const;
  void beginOverride();
  bool isOverridden();
  mce::Mesh endOverride(const gsl::basic_string_span<char const ,-1>);
  std::vector<TessellatorQuadInfo,std::allocator<TessellatorQuadInfo> >& getFaces();
  const std::vector<TessellatorQuadInfo,std::allocator<TessellatorQuadInfo> >& getFaces() const;
  mce::MeshData& getCurrentMesh();
  const mce::MeshData& getCurrentMesh() const;
  void setMeshData(mce::MeshData&);
  mce::MeshData& getCurrentMeshNonConst();
  void simpleQuad(const Vec3&, const Vec2&, const Vec3&, const Vec2&, const Vec3&, const Vec2&, const Vec3&, const Vec2&);
  Tessellator& operator=(const Tessellator&);
  void _tex(const Vec2&, int32_t);
  void _checkFieldSupport(const mce::VertexField);
  void __autoclassinit2(uint64_t);
  void* __vecDelDtor(uint32_t);
};
