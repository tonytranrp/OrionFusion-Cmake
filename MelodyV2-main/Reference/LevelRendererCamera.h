
class LevelRendererCamera : public PlayerListener, public LevelListener { /* Size=0x1508 */
  /* 0x0000: fields for PlayerListener */
  /* 0x0008: fields for LevelListener */
  /* 0x0010 */ uint64_t mChunkQueueSize;
  /* 0x0018 */ uint64_t mTerrainChunkQueueSize[3][18];
  /* 0x01c8 */ std::unordered_multimap<HashedString,Actor *,std::hash<HashedString>,std::equal_to<HashedString>,std::allocator<std::pair<HashedString const ,Actor *> > > mEntityRenderQueue;
  /* 0x0208 */ SortedMeshDrawList mSortedMeshDrawList;
  /* 0x0220 */ std::vector<gsl::not_null<BlockActor *>,std::allocator<gsl::not_null<BlockActor *> > > mBlockEntityRenderQueue;
  /* 0x0238 */ std::vector<gsl::not_null<BlockActor *>,std::allocator<gsl::not_null<BlockActor *> > > mBlockEntityRenderAlphaQueue;
  /* 0x0250 */ std::vector<gsl::not_null<BlockActor *>,std::allocator<gsl::not_null<BlockActor *> > > mBlockEntityShadowQueue;
  /* 0x0268 */ std::vector<gsl::not_null<BlockActor *>,std::allocator<gsl::not_null<BlockActor *> > > mBlockEntityProcessBarRenderQueue;
  /* 0x0280 */ mce::MaterialPtr shadowVolumeBack;
  /* 0x0290 */ mce::MaterialPtr shadowVolumeFront;
  /* 0x02a0 */ mce::MaterialPtr shadowOverlayMat;
  /* 0x02b0 */ mce::MaterialPtr starsMaterial;
  /* 0x02c0 */ mce::MaterialPtr skyPlaneMaterial;
  /* 0x02d0 */ mce::MaterialPtr sunMoonMaterial;
  /* 0x02e0 */ mce::MaterialPtr endSkyMaterial;
  /* 0x02f0 */ mce::MaterialPtr cloudMaterial;
  /* 0x0300 */ mce::MaterialPtr wireframeMaterial;
  /* 0x0310 */ mce::MaterialPtr mCubemapMaterial;
  /* 0x0320 */ std::vector<mce::TexturePtr,std::allocator<mce::TexturePtr> > mCubemapTextures;
  /* 0x0338 */ mce::ClientTexture mCubemapTexture;
  /* 0x0348 */ OverlayTextureMap mOverlayTextureMap;
  /* 0x03e0 */ OverlayTextureMap::TextureId mActiveOverlayTextureId;
  /* 0x03e8 */ TerrainMaterialVariationManager mTerrainMaterialVariationManager;
  /* 0x0478 */ float mDeltaTime;
  /* 0x047c */ float mLastTime;
  /* 0x0480 */ float mWaterLevel;
  /* 0x0484 */ glm::tvec2<float,0> mFogControl;
  /* 0x048c */ float mFogBrOriginal;
  /* 0x0490 */ float mFogBr;
  /* 0x0494 */ float mBaseFogEnd;
  /* 0x0498 */ float mBaseFogStart;
  /* 0x049c */ FogDistanceSetting mCurrentDistanceFog;
  /* 0x04b8 */ FogDistanceSetting mLastTargetDistanceFog;
  /* 0x04d4 */ FogVolumetricDensitySetting mCurrentFogDensity;
  /* 0x04e4 */ FogVolumetricCoefficientSetting mAirFogCoefficient;
  /* 0x0504 */ FogVolumetricCoefficientSetting mWaterFogCoefficient;
  /* 0x0524 */ FogVolumetricCoefficientSetting mCloudFogCoefficient;
  /* 0x0544 */ bool mFogWasUnderwaterLastCheck;
  /* 0x0545 */ bool mFogWasUnderLavaLastCheck;
  /* 0x0546 */ bool mFogWasUnderPowderSnowLastCheck;
  /* 0x0547 */ bool mBlendFogThisFrame;
  /* 0x0548 */ float mBlindnessLevel;
  /* 0x054c */ const float mRenderDistanceCloudFadeOutMultiplier;
  /* 0x0550 */ float mRainPosX;
  /* 0x0554 */ float mRainPosY;
  /* 0x0558 */ float mRainPosZ;
  /* 0x055c */ int32_t mRainPosSamples;
  /* 0x0560 */ int32_t mRainSoundTime;
  /* 0x0564 */ int32_t mRainCount;
  /* 0x0568 */ float mFakeHDR;
  /* 0x056c */ float mAverageBrightness;
  /* 0x0570 */ uint32_t mFrameID;
  /* 0x0574 */ int32_t mViewAreaDistance;
  /* 0x0578 */ float mFarChunksDistance;
  /* 0x057c */ float mRenderDistance;
  /* 0x0580 */ float mCullEndDistance;
  /* 0x0584 */ const int32_t mMaxInflightChunks;
  /* 0x0588 */ std::shared_ptr<GridArea<std::shared_ptr<RenderChunkInstanced> > > mViewArea;
  /* 0x0598 */ BlockPos mLastFaceSortPos;
  /* 0x05a4 */ Vec3 mLastFaceSortDir;
  /* 0x05b0 */ Vec3 mLastDirtySortPos;
  /* 0x05bc */ BlockPos mLastNearbyFaceSortPos;
  /* 0x05c8 */ LevelRendererCamera::RenderChunkPosBounds mLastFaceSortBounds;
  /* 0x05e0 */ Vec3 mLastChunkResortPos;
  /* 0x05ec */ Vec3 mCameraPos;
  /* 0x05f8 */ Vec3 mCameraTargetPos;
  /* 0x0608 */ std::shared_ptr<mce::Mesh> mCloudsMesh;
  /* 0x0618 */ mce::Camera mWorldSpaceCamera;
  /* 0x0918 */ Matrix mSunMatrix;
  /* 0x0958 */ Matrix mMoonMatrix;
  /* 0x0998 */ glm::tvec3<float,0> mSunDirection;
  /* 0x09a4 */ glm::tvec3<float,0> mMoonDirection;
  /* 0x09b0 */ std::unique_ptr<Tessellator,std::default_delete<Tessellator> > mCloudTessellator;
  /* 0x09b8 */ std::unique_ptr<TextureTessellator,std::default_delete<TextureTessellator> > mCloudTextureTessellator;
  /* 0x09c0 */ Vec3 mLastCloudUpdatePosition;
  /* 0x09cc */ unsigned char mLastCloudSide;
  /* 0x09cd */ bool mUpdatingClouds;
  /* 0x09d0 */ std::vector<Actor *,std::allocator<Actor *> > mWaterHoleEntityQueue;
  /* 0x09e8 */ std::unique_ptr<WeatherRenderer,std::default_delete<WeatherRenderer> > mWeatherRenderer;
  /* 0x09f0 */ std::unique_ptr<ChunkRenderObjectCollection,std::default_delete<ChunkRenderObjectCollection> > mChunkRenderObjects;
  /* 0x09f8 */ std::unique_ptr<Bedrock::Threading::AsyncDeferredResultT<void>,std::default_delete<Bedrock::Threading::AsyncDeferredResultT<void> > > mFrameBuilderChunkRenderObjectsReadyEvent;
  /* 0x0a00 */ bool mCameraUnderWater;
  /* 0x0a01 */ bool mCameraUnderLiquid;
  /* 0x0a02 */ bool mCameraUnderPowderSnow;
  /* 0x0a03 */ bool mCameraUnderLava;
  /* 0x0a04 */ bool mCameraInRain;
  /* 0x0a05 */ bool mShowSky;
  /* 0x0a08 */ Level& mLevel;
  /* 0x0a10 */ std::unique_ptr<BlockSource,std::default_delete<BlockSource> > mViewRegion;
  /* 0x0a18 */ Dimension* mDimension;
  /* 0x0a20 */ int16_t mCloudHeight;
  /* 0x0a28 */ LevelRenderer& mLevelRenderer;
  /* 0x0a30 */ LevelBuilder mLevelBuilder;
  /* 0x11e0 */ ResourcePackManager& mResourcePackManager;
  /* 0x11e8 */ mce::TextureGroup& mTextures;
  /* 0x11f0 */ std::vector<BlockActor *,std::allocator<BlockActor *> > mTempBlockEntityList;
  /* 0x1208 */ std::weak_ptr<cg::ImageBuffer> mCloudsImage;
  /* 0x1218 */ std::unique_ptr<LevelRendererCameraProxy,std::default_delete<LevelRendererCameraProxy> > mProxy;
  /* 0x1220 */ ParticleRenderData mParticleRenderData;
  /* 0x12e8 */ double mLastFrameTimeStart;
  /* 0x12f0 */ HistoricalFrameTimes mHistoricalFrameTimes;
  /* 0x14d8 */ bool mRenderOpacityActor;
  /* 0x14dc */ mce::Color mUserDefineEmptyColor;
  /* 0x14f0 */ std::vector<mce::Color,std::allocator<mce::Color> > mUserDefineColors;
  
  LevelRendererCamera(IClientInstance&, Level&, LevelRenderer&);
  virtual ~LevelRendererCamera();
  virtual void addCameraListenerToRenderChunkCoordinator();
  virtual void onAppSuspended();
  virtual void onAppResumed();
  virtual void onDeviceLost();
  virtual void onLowMemory();
  void initResources();
  void frameUpdate(ClientFrameUpdateContext&);
  virtual void tickLevelRendererCamera();
  void tickClouds(const bool, const float);
  virtual void tickRain();
  RenderChunkInstanced* getRenderChunkInstancedAt(const SubChunkPos&) const;
  std::shared_ptr<RenderChunkInstanced> getRenderChunkInstancedAtShared(const SubChunkPos&) const;
  RenderChunkInstanced* getOrCreateRenderChunkInstancedAt(const SubChunkPos&);
  uint64_t fetchRenderChunkTotalCount() const;
  uint64_t fetchRenderChunkReadyCount() const;
  ViewRenderObject createViewRenderObject(ScreenContext&, unsigned char);
  void updateViewArea(const LevelRenderPreRenderUpdateParameters&);
  virtual void callRenderNameTags(ScreenContext&, const ViewRenderObject&, Font&);
  virtual NameTagRenderObjectCollection extractNameTags(ScreenContext&) const;
  virtual void callRenderCracks(BaseActorRenderContext&, const ViewRenderObject&);
  virtual CrackRenderObjectCollection extractCracks(ScreenContext&) const;
  virtual void renderEntityEffects(BaseActorRenderContext&);
  virtual void renderBlockEntities(BaseActorRenderContext&, bool);
  void _checkAndUpdateEntityInterlockVisibilityState(ActorTerrainInterlockData&, const std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >&);
  void calSunMoonDir(ScreenContext&, const ViewRenderObject&);
  void renderAtmosphere(ScreenContext&, const ViewRenderObject&) const;
  void renderPlayerVision(ScreenContext&) const;
  void renderSky(ScreenContext&, const ViewRenderObject&) const;
  virtual void renderBindEffects(BaseActorRenderContext&);
  void renderNameTagsInFrame(BaseActorRenderContext&);
  virtual void renderFonts(BaseActorRenderContext&);
  virtual void renderHealth(BaseActorRenderContext&, const ViewRenderData&);
  virtual void renderProcessBar(BaseActorRenderContext&, const ViewRenderData&);
  void updateEditViewArea(const LevelRenderPreRenderUpdateParameters&, const Vec3&);
  void changeCubemapTexture(std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >);
  void resetCubemapTexture(const Dimension&);
  void getCubemapTexture(std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >&);
  void setupCustomSkyColor(ScreenContext&);
  void renderStructureWireframes(BaseActorRenderContext&, const IClientInstance&, const ViewRenderObject&);
  void renderEntities(BaseActorRenderContext&);
  void renderFreeObjs(ScreenContext&);
  void renderFreeObjsBindEffects(ScreenContext&);
  void renderWaterHoles(BaseActorRenderContext&) const;
  virtual void renderHolographicCursor(ScreenContext&);
  virtual void renderVRHitFlash(ScreenContext&);
  void updatePerChunkFaceSortState(const Vec3&, const Vec3&, bool);
  bool isAABBVisible(const AABB&, bool) const;
  void updateFarChunksDistance();
  virtual void onWillChangeDimension(Player&);
  virtual void onDimensionChanged(Player&);
  virtual void onPlayerDestruction(Player&);
  void onViewRadiusChanged(bool);
  void setViewArea(const int32_t);
  const GridArea<std::shared_ptr<RenderChunkInstanced> >& getViewArea() const;
  int32_t getViewAreaDistance() const;
  int32_t getFarChunksDistance() const;
  void determineUnderwaterStatus(BlockSource&);
  float skyDarkeningFactor() const;
  virtual bool getForceFog(const Actor&) const;
  virtual void setupFog(ScreenContext&, const float);
  virtual float getAmbientBrightness() const;
  void recalculateRenderDistance(const float);
  virtual void preRenderUpdate(ScreenContext&, LevelRenderPreRenderUpdateParameters&);
  virtual void render(BaseActorRenderContext&, const ViewRenderObject&, IClientInstance&, LevelRendererCommandListInit&);
  virtual void postRenderUpdate();
  virtual bool isPositionTooCloseToCamera(const Vec3&) const;
  mce::Color getFogClearColor();
  mce::Color& getFogColor();
  float getFogBrightness(float) const;
  float getFogEndDistance() const;
  float getCullEndDistance() const;
  float getRenderDistance();
  const Vec3& getCameraPos() const;
  const Vec3& getCameraTargetPos() const;
  Vec3 getCloudCenterPos(const float) const;
  void setDimension(Dimension*, bool, bool);
  AutomaticID<Dimension,int> getDimensionID() const;
  std::optional<DimensionHeightRange> getDimensionHeightRange() const;
  LevelBuilder& getLevelBuilder();
  Level& getLevel();
  const GridArea<std::shared_ptr<RenderChunkInstanced> >& getLevelRendererArea() const;
  const Matrix& getSunMatrix() const;
  float getZFar() const;
  float getRenderDistanceZFar() const;
  const LevelRenderer& getLevelRenderer() const;
  LevelRenderer& getLevelRendererNonConst();
  const mce::Camera& getWorldSpaceCamera() const;
  bool isUnderWater() const;
  bool isUnderLava() const;
  void renderChunkVisibilityChanged(RenderChunkShared&, bool);
  void resetChunkCullingData(const ChunkPos&);
  void renderChunkImmediateChanged(const SubChunkPos&);
  virtual void blockEntityAboutToBeRemoved(BlockSource&, std::shared_ptr<BlockActor>);
  bool isAboveClouds(const BlockPos&) const;
  BlockSource* getViewRegion() const;
  void addAverageBrightnessSample(float);
  virtual void notifyGeoChangedForAffectedEntities(RenderChunkShared&, unsigned char);
  uint64_t getRenderChunkInstancedCount();
  uint64_t getRenderChunkInstancedBaseMemoryUsed();
  uint64_t getRenderChunkInstancedIndexMemoryUsed();
  uint64_t getRenderChunkInstancedDifferentGeoCount();
  void queueChunk(ChunkRenderObjectCollection&, const RenderChunkInstanced&, float, float, const TerrainMaterialVariationManager&, optional_ref<TerrainMaterialVariationManager const >);
  void doneQueuingChunks();
  LevelRendererCameraProxy* getProxy();
  const TerrainMaterialVariationManager& getCurrentVariationManager() const;
  void setOverlayTexture(const OverlayTextureMap::TextureId&);
  OverlayTextureMap::TextureId getOverlayTextureId();
  mce::TexturePtr getOverlayTexturePtr();
  const std::unordered_multimap<HashedString,Actor *,std::hash<HashedString>,std::equal_to<HashedString>,std::allocator<std::pair<HashedString const ,Actor *> > >& getActorRenderQueue();
  virtual void queueRenderEntities(const LevelRenderPreRenderUpdateParameters&);
  void _updateParticleSystemVisibility();
  void _resortNearbyChunks(const Vec3&, const GridArea<std::shared_ptr<RenderChunkInstanced> >&);
  void _releaseResources();
  void _ResetArea();
  virtual const Block* _getBlockForBlockEnity(const BlockActor&);
  virtual void _fetchAdditionalBlockEntities(std::vector<BlockActor *,std::allocator<BlockActor *> >&);
  void setupViewArea();
  uint64_t getAllocatedChunks() const;
  virtual FogDefinition::DistanceSettingType _getFogDistanceSettingType() const;
  virtual FogDefinition::DensitySettingType _getFogDensitySettingType() const;
  const HistoricalFrameTimes& getHistoricalFrameTimes() const;
  HistoricalFrameTimes& getHistoricalFrameTimes();
  void _initCubemapTextures(const Dimension&);
  void _initSkyTextures(IClientInstance&, const Dimension&);
  void _notifyPerspectiveCameraMoved(const SubChunkPos&, const Vec3&, bool, const GridArea<std::shared_ptr<RenderChunkInstanced> >&);
  void _notifyOrthographicCameraMoved(const SubChunkPos&, const Vec3&, const GridArea<std::shared_ptr<RenderChunkInstanced> >&);
  void _updateCloudHeight();
  bool _shouldRenderBlockType(const BlockLegacy*);
  GridArea<std::shared_ptr<RenderChunkInstanced> >& _viewAreaMutable();
  void _addToRenderChunkQueue(ChunkRenderObjectCollection&, const TerrainMaterialVariationManager&, const TerrainLayer&, const RenderChunkInstanced&, uint64_t, const BlockPos&);
  CloudRenderObject _extractClouds(ScreenContext&) const;
  ActorShadowRenderObjectCollection _extractEntityShadows(ScreenContext&) const;
  SkyRenderObject _extractSky(ScreenContext&) const;
  gsl::not_null<Bedrock::NonOwnerPointer<FogDefinitionRegistry> > _getFogDefinitionRegistry() const;
  gsl::not_null<Bedrock::NonOwnerPointer<FogManager> > _getFogManager() const;
  void _addBiomeFogDefinitionToManager(const BlockPos&) const;
  FogDistanceSetting _getCurrentFixedDistanceFogSetting(float) const;
  FogVolumetricDensitySetting _getCurrentDensityFogSetting() const;
  FogVolumetricCoefficientSetting _getCurrentCoefficientFogSetting(FogDefinition::CoefficientSettingType) const;
  void _applyAdjustmentsForAir(FogDistanceSetting&, ScreenContext&, const float) const;
  void _applyAdjustmentsForUnderwater(FogDistanceSetting&) const;
  void __autoclassinit2(uint64_t);
  virtual void* __vecDelDtor(uint32_t);
  
  static float getCameraDeltaToUpdateArea(const float);
  static void renderStars(ScreenContext&, const ViewRenderData&, const SkyRenderObject&);
  static void renderSunOrMoon(ScreenContext&, const ViewRenderData&, const SkyRenderObject&, bool);
  static void renderClouds(ScreenContext&, const ViewRenderObject&);
  static void renderShadows(ScreenContext&, const ViewRenderObject&);
  static void renderMilkyWay(ScreenContext&, const ViewRenderData&, const SkyRenderObject&);
  static void renderMeteor(ScreenContext&, const ViewRenderData&, const SkyRenderObject&);
  static FogDistanceSetting interpolateFog(const FogDistanceSetting&, const FogDistanceSetting&, bool, bool, float);
  static float calculateFogScaleByDepth(const BlockPos&, float);
  static float calculateFogScaleByVisionClarity(float);
};
