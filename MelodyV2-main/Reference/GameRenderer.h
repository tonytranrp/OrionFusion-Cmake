
class GameRenderer { /* Size=0x3d0 */
  /* 0x0008 */ std::unique_ptr<FrameRenderObject,std::function<void __cdecl(FrameRenderObject *)> > mFrameObject_NoAccessOutsideRender;
  /* 0x0050 */ LinearAllocator<FrameRenderObject> mLinearAllocator;
  /* 0x0060 */ MinecraftGraphicsPipeline mMinecraftGraphicsPipeline;
  /* 0x0190 */ MinecraftGraphics& mMinecraftGraphics;
  /* 0x0198 */ IClientInstance* mClient;
  /* 0x01a0 */ IClientInstance& mPrimaryClient;
  /* 0x01a8 */ mce::RenderGraph mRenderGraph;
  /* 0x0200 */ mce::Clock mClock;
  /* 0x0220 */ std::unique_ptr<Tessellator,std::default_delete<Tessellator> > mTessellator;
  /* 0x0228 */ TickingTextureStage* mTickingTextureStage;
  /* 0x0230 */ TickingTextureStage* mTickingUITextureStage;
  /* 0x0238 */ Netease::RNGLStage* mRNGLStage;
  /* 0x0240 */ float mLastClockTime;
  /* 0x0244 */ bool mFlushedInitCommandList;
  /* 0x0248 */ int32_t _tick;
  /* 0x024c */ int16_t mPointerX;
  /* 0x024e */ int16_t mPointerY;
  /* 0x0250 */ bool mUseLowFrequencyUIRender;
  /* 0x0258 */ std::unique_ptr<InsideCubeRenderer,std::default_delete<InsideCubeRenderer> > mInsideCubeRenderer;
  /* 0x0260 */ std::vector<std::shared_ptr<PlayerRenderView>,std::allocator<std::shared_ptr<PlayerRenderView> > > mPlayerViews;
  /* 0x0278 */ optional_ref<mce::RenderStage> mDirectOutputStage;
  /* 0x0280 */ optional_ref<mce::RenderStage> mUIStage;
  /* 0x0288 */ optional_ref<mce::RenderStage> mFrameBufferOutputStage;
  /* 0x0290 */ optional_ref<CommandListQueue> mCommandListQueue;
  /* 0x0298 */ optional_ref<mce::RenderStage> mLeftEyeOutputStage;
  /* 0x02a0 */ optional_ref<mce::RenderStage> mRightEyeOutputStage;
  /* 0x02a8 */ std::optional<ScreenContext> mCurrentFrameScreenContext;
  /* 0x0390 */ Matrix mCubemapWorldMatrix;
  static mce::Color mClearColor;
  static bool mSplitScreenActive;
  
  GameRenderer(IClientInstance&, MinecraftGraphics&);
  virtual ~GameRenderer();
  void cleanupRenderGraph();
  void createRenderGraph(mce::RenderContext&, bool);
  void recreateTickingTextureStage();
  void setClient(IClientInstance&);
  void onSubClientRemoved(const IClientInstance&);
  void setLevel(Level*, Dimension*);
  void tick();
  void renderCurrentFrame(float);
  void renderDebugScreen(ScreenContext&, IClientInstance&, RectangleArea&);
  void renderCursor(ScreenContext&, float, float);
  void onAppResumed();
  void onAppSuspended();
  void setLowFrequencyUIRender(bool);
  bool useLowFrequencyUIRender() const;
  void renderInsideCubes(ScreenContext&);
  bool wasViewInsideSolidBlockLastRender() const;
  void setInsideCubePlane(Vec4&, Vec3&);
  const Matrix& getCubemapWorldMat() const;
  Tessellator& getTessellator();
  ScreenContext makeScreenContext(const float);
  void startFrame(mce::RenderContext&);
  void endFrame(mce::RenderContext&);
  HitResult pick(int32_t, int32_t);
  void _prepareFrame(ScreenContext&);
  std::unique_ptr<FrameRenderObject,std::function<void __cdecl(FrameRenderObject *)> > _extractFrame(ScreenContext&, bool);
  void _tickLightTexture(const Dimension&, float);
  void _checkAndDrawInputUI(ScreenContext&);
  std::weak_ptr<PlayerRenderView> addPlayerRenderView(LevelRenderer&);
  void removePlayerRenderView(PlayerRenderView*);
  void setCommandListQueue(CommandListQueue&);
  Netease::RNGLStage* getRNGLStage();
  optional_ref<mce::RenderStage>& getGamePlayStage();
  void __autoclassinit2(uint64_t);
  virtual void* __vecDelDtor(uint32_t);
  
  static void setClearColor(IClientInstance&, ScreenContext&);
  static void clearRenderTarget(ScreenContext&);
};
