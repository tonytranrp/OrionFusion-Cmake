
class mce::TextureGroup : public mce::TextureGroupBase { /* Size=0x108 */
  /* 0x0000: fields for mce::TextureGroupBase */
  /* 0x0008 */ std::map<ResourceLocation,BedrockTexture,std::less<ResourceLocation>,std::allocator<std::pair<ResourceLocation const ,BedrockTexture> > > mLoadedTextures;
  /* 0x0018 */ std::map<std::pair<ResourceLocation,enum TextureLoadMode>,std::shared_ptr<Bedrock::Threading::IAsyncResult<void> >,std::less<std::pair<ResourceLocation,enum TextureLoadMode> >,std::allocator<std::pair<std::pair<ResourceLocation,enum TextureLoadMode> const ,std::shared_ptr<Bedrock::Threading::IAsyncResult<void> > > > > mLoadQueueResults;
  /* 0x0028 */ std::map<std::pair<ResourceLocation,enum TextureLoadMode>,std::optional<enum ResourceLoadType>,std::less<std::pair<ResourceLocation,enum TextureLoadMode> >,std::allocator<std::pair<std::pair<ResourceLocation,enum TextureLoadMode> const ,std::optional<enum ResourceLoadType> > > > mRateLimitedTextureLoadList;
  /* 0x0038 */ std::shared_ptr<Bedrock::Threading::IAsyncResult<void> > mQueuLoadResultCoroutine;
  /* 0x0048 */ std::set<ResourceLocation,std::less<ResourceLocation>,std::allocator<ResourceLocation> > mTouchedTextures;
  /* 0x0058 */ ImageBufferResourceManager mImageBufferCache;
  /* 0x0068 */ std::unique_ptr<mce::LRUCache,std::default_delete<mce::LRUCache> > mLRUCache;
  /* 0x0070 */ ResourceLoadManager& mResourceLoadManager;
  /* 0x0078 */ Bedrock::Threading::CountTracker mPendingReloadCounter;
  /* 0x0080 */ std::atomic<unsigned __int64> mOutstandingTaskMemory;
  /* 0x0088 */ std::atomic<unsigned __int64> mOutstandingTaskCount;
  /* 0x0090 */ mce::TextureResourceService& mResourceService;
  /* 0x0098 */ const cg::ImageBuffer mMissingTexture;
  /* 0x00f0 */ uint32_t mMaxTextureQueueDepth;
  /* 0x00f8 */ std::chrono::duration<__int64,std::ratio<1,1000> > mLoadDelayTime;
  /* 0x0100 */ bool mEnableAsyncFileLoads;
  /* 0x0101 */ bool mEnableMissingAsyncTextureLoad;
  
  TextureGroup(ResourceLoadManager&, mce::TextureResourceService&);
  virtual ~TextureGroup();
  void addEmptyTexture(const ResourceLocation&, const int32_t, const int32_t);
  void loadTexturesAsync(const gsl::span<ResourceLocationPair,-1>, const std::optional<enum ResourceLoadType>);
  void loadTexturesAsync(const gsl::span<ResourceLocation,-1>, const std::optional<enum ResourceLoadType>);
  bool loadImageIntoCacheSync(const ResourceLocation&);
  bool isLoaded(const ResourceLocation&, bool) const;
  IsMissingTexture isMissingTexture(const ResourceLocation&) const;
  void touchTexture(const ResourceLocation&);
  BedrockTexture& uploadTexture(const ResourceLocation&, cg::ImageBuffer);
  BedrockTexture& uploadTexture(const ResourceLocation&, const mce::TextureContainer&);
  BedrockTexture& uploadTextureSet(const ResourceLocation&, gsl::not_null<std::shared_ptr<cg::TextureSetDefinition> >);
  void frameUpdate(FrameUpdateContext&);
  bool unloadTextureAndCachedImage(const ResourceLocation&, const bool);
  void unloadTexture(const ResourceLocation&);
  void unloadAllTextures();
  bool isReloading() const;
  void reloadAllTextures();
  virtual mce::TexturePtr getTexture(const ResourceLocation&, const bool);
  const BedrockTextureData* getBedrockTextureData(const ResourceLocation&) const;
  std::optional<mce::TextureDescription> getTextureMetadata(const ResourceLocation&) const;
  void setTextureMetadata(const ResourceLocation&, const gsl::not_null<std::shared_ptr<cg::TextureSetDefinition> >);
  void setTextureMetadata(const ResourceLocation&, const cg::TextureSetImageDescription&, const std::optional<enum IsMissingTexture>);
  void setTextureMetadata(const ResourceLocation&, const mce::TextureDescription&);
  void reloadImages(const gsl::span<ResourceLocationPair,-1>, const gsl::span<ResourceLocation,-1>, std::vector<ResourceLocation,std::allocator<ResourceLocation> >, const ImageCacheMode);
  void unloadUnusedTextureSafe();
  bool unloadTextureSafe(const ResourceLocation&);
  bool unloadCPUStorage(const ResourceLocation&);
  void setLRUCacheSize(uint64_t);
  void disableLRU();
  void unloadFileSystem(const ResourceFileSystem);
  void unloadBedrockTextureAndCachedImage(const ResourceLocation&, BedrockTexture&);
  void clearCPUStorage();
  void enableLRUCache(uint64_t);
  void trimLRUCache();
  const cg::ImageBuffer& getMissingImageBuffer() const;
  cg::ImageBuffer* getCachedImage(const ResourceLocation&) const;
  cg::ImageBuffer* insertImageIntoCache(const ResourceLocation&, cg::ImageBuffer&);
  void setAsyncFileLoading(const bool);
  void setUseMissingTextureWhileAsycLoading(const bool);
  void setAsyncLoadQueueSize(const uint32_t);
  void setAsyncTextureLoadDelay(const std::chrono::duration<__int64,std::ratio<1,1000> >);
  bool areAsyncFileLoadsEnabled() const;
  ImageBufferResourceManager getImageBufferResourceManagerCopy() const;
  void CancelTextureLoad(const ResourceLocation&, const TextureLoadMode);
  std::shared_ptr<Bedrock::Threading::IAsyncResult<void> > loadTextureSetAsync(const ResourceLocation&, const TextureLoadMode, const std::optional<enum ResourceLoadType>, const std::optional<unsigned int>);
  std::shared_ptr<Bedrock::Threading::IAsyncResult<void> > getLoadQueueHandle(const std::pair<ResourceLocation,enum TextureLoadMode>&);
  void loadTexturesSync(const gsl::span<ResourceLocation,-1>);
  void finishImageLoad(const ResourceLocation&, cg::ImageBuffer&);
  bool textureIsQueuedOrBeingLoaded(const std::pair<ResourceLocation,enum TextureLoadMode>&);
  void addTextureToDeferredLoadQueue(const std::pair<ResourceLocation,enum TextureLoadMode>&);
  void __autoclassinit2(uint64_t);
  virtual void* __vecDelDtor(uint32_t);
  
  static mce::Image getMissingImageCopy();
};
