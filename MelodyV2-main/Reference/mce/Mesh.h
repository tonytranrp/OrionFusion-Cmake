
class mce::Mesh : public mce::IndexBufferContainer { /* Size=0x1b0 */
  /* 0x0000: fields for mce::IndexBufferContainer */
  /* 0x0020 */ std::variant<std::monostate,unsigned __int64,glm::tvec3<int,0> > mCacheKey;
  /* 0x0038 */ bool mTemporary;
  /* 0x0039 */ mce::PrimitiveMode mPrimitiveMode;
  /* 0x0040 */ std::basic_string<char,std::char_traits<char>,std::allocator<char> > mDebugName;
  /* 0x0060 */ std::weak_ptr<mce::BufferResourceService> mBufferResourceService;
  /* 0x0070 */ mce::MeshData mMeshData;
  /* 0x0160 */ mce::ClientResourcePointer<mce::ResourcePointer<std::variant<std::monostate,mce::Buffer,mce::ClientResourcePointer<mce::ResourcePointer<dragon::mesh::ResolvedVertexBufferResource,mce::ResourceBlockTemplate<dragon::mesh::ResolvedVertexBufferResource,mce::UncheckedHandleTracker,dragon::BufferDescription>,std::shared_ptr> >,mce::ClientResourcePointer<mce::ResourcePointer<dragon::mesh::ResolvedIndexBufferResource,mce::ResourceBlockTemplate<dragon::mesh::ResolvedIndexBufferResource,mce::UncheckedHandleTracker,dragon::BufferDescription>,std::shared_ptr> > >,mce::ResourceBlockTemplate<std::variant<std::monostate,mce::Buffer,mce::ClientResourcePointer<mce::ResourcePointer<dragon::mesh::ResolvedVertexBufferResource,mce::ResourceBlockTemplate<dragon::mesh::ResolvedVertexBufferResource,mce::UncheckedHandleTracker,dragon::BufferDescription>,std::shared_ptr> >,mce::ClientResourcePointer<mce::ResourcePointer<dragon::mesh::ResolvedIndexBufferResource,mce::ResourceBlockTemplate<dragon::mesh::ResolvedIndexBufferResource,mce::UncheckedHandleTracker,dragon::BufferDescription>,std::shared_ptr> > >,mce::PerFrameHandleTracker,dragon::BufferDescription>,std::shared_ptr> > mVertexBuffer;
  /* 0x0170 */ std::optional<unsigned int> mVertexCount;
  /* 0x0178 */ mce::VertexFormat mVertexFormat;
  /* 0x0198 */ std::vector<unsigned char,std::allocator<unsigned char> > mRawData;
  
  Mesh(const mce::Mesh&);
  Mesh(mce::Mesh&);
  Mesh(std::shared_ptr<mce::BufferResourceService>&, mce::MeshData&, const bool, const gsl::basic_string_span<char const ,-1>);
  Mesh();
  ~Mesh();
  mce::Mesh& operator=(const mce::Mesh&);
  mce::Mesh& operator=(mce::Mesh&);
  dragon::mesh::Mesh operator class dragon::mesh::Mesh() const;
  const mce::VertexFormat& getVertexFormat() const;
  void load(mce::BufferResourceService&);
  void releaseVertexBuffer();
  bool isValid() const;
  bool areBuffersValid() const;
  void reset();
  bool hasField(const mce::VertexField) const;
  void renderMesh(mce::MeshContext&, const dragon::RenderMetadata&, const mce::MaterialPtr&, const std::variant<std::monostate,mce::TexturePtr,mce::ClientTexture,mce::ServerTexture>&, uint32_t, uint32_t, const mce::IndexBufferContainer*) const;
  void renderMesh(mce::MeshContext&, const mce::MaterialPtr&, const gsl::span<mce::ServerTexture const *,-1>, uint32_t, uint32_t, const mce::IndexBufferContainer*) const;
  void renderMesh(mce::MeshContext&, const mce::MaterialPtr&, const gsl::span<mce::ClientTexture const *,-1>, uint32_t, uint32_t, const mce::IndexBufferContainer*) const;
  void renderMesh(mce::MeshContext&, const mce::MaterialPtr&, const gsl::span<mce::TexturePtr const ,-1>, uint32_t, uint32_t, const mce::IndexBufferContainer*) const;
  void renderMesh(mce::MeshContext&, const mce::MaterialPtr&, const std::initializer_list<std::reference_wrapper<mce::TexturePtr const > >, uint32_t, uint32_t, const mce::IndexBufferContainer*) const;
  void renderMesh(mce::MeshContext&, const mce::MaterialPtr&, const std::initializer_list<std::reference_wrapper<mce::Texture const > >, uint32_t, uint32_t, const mce::IndexBufferContainer*) const;
  void renderMesh(mce::MeshContext&, const mce::MaterialPtr&, const std::variant<std::monostate,mce::TexturePtr,mce::ClientTexture,mce::ServerTexture>&, uint32_t, uint32_t, const mce::IndexBufferContainer*) const;
  void renderMesh(mce::MeshContext&, const mce::MaterialPtr&, uint32_t, uint32_t, const mce::IndexBufferContainer*) const;
  const mce::ClientResourcePointer<mce::ResourcePointer<std::variant<std::monostate,mce::Buffer,mce::ClientResourcePointer<mce::ResourcePointer<dragon::mesh::ResolvedVertexBufferResource,mce::ResourceBlockTemplate<dragon::mesh::ResolvedVertexBufferResource,mce::UncheckedHandleTracker,dragon::BufferDescription>,std::shared_ptr> >,mce::ClientResourcePointer<mce::ResourcePointer<dragon::mesh::ResolvedIndexBufferResource,mce::ResourceBlockTemplate<dragon::mesh::ResolvedIndexBufferResource,mce::UncheckedHandleTracker,dragon::BufferDescription>,std::shared_ptr> > >,mce::ResourceBlockTemplate<std::variant<std::monostate,mce::Buffer,mce::ClientResourcePointer<mce::ResourcePointer<dragon::mesh::ResolvedVertexBufferResource,mce::ResourceBlockTemplate<dragon::mesh::ResolvedVertexBufferResource,mce::UncheckedHandleTracker,dragon::BufferDescription>,std::shared_ptr> >,mce::ClientResourcePointer<mce::ResourcePointer<dragon::mesh::ResolvedIndexBufferResource,mce::ResourceBlockTemplate<dragon::mesh::ResolvedIndexBufferResource,mce::UncheckedHandleTracker,dragon::BufferDescription>,std::shared_ptr> > >,mce::PerFrameHandleTracker,dragon::BufferDescription>,std::shared_ptr> >& getVertexBuffer() const;
  mce::PrimitiveMode getPrimitiveMode() const;
  uint64_t getMeshSize() const;
  uint64_t getMeshIndexBufferSize() const;
  uint64_t getMeshVertexCount() const;
  bool isTemporary() const;
  gsl::span<unsigned char const ,-1> getRawData() const;
  void* getRawDataPtr() const;
  bool hasCPUData() const;
  void prepareRenderData(const mce::VertexFormat&) const;
  void generateHALData(const mce::VertexFormat*) const;
  void draw(mce::MeshContext&, uint32_t) const;
  mce::MeshData& getMeshData();
  void _renderMesh(mce::MeshContext&, const mce::MaterialPtr&, const boost::container::static_vector<std::variant<std::monostate,mce::TexturePtr,mce::ClientTexture,mce::ServerTexture>,8>&, uint32_t, uint32_t, const mce::IndexBufferContainer*, std::optional<dragon::RenderMetadata>) const;
  void _bindShader(mce::MeshContext&, uint32_t, const mce::MaterialPtr&) const;
  void _move(mce::Mesh&);
  bool _loadRawData(mce::BufferResourceService&, const gsl::basic_string_span<char const ,-1>) const;
  void _freeHALData() const;
  uint32_t _vertexCount() const;
  void __autoclassinit2(uint64_t);
  void* __vecDelDtor(uint32_t);
};
